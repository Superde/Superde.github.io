<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dymzcc.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="三环三星">
<meta property="og:url" content="https://dymzcc.github.io/index.html">
<meta property="og:site_name" content="三环三星">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="dede">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dymzcc.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>三环三星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">三环三星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习，记录，分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dymzcc.github.io/2020/10/09/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dede">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三环三星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/09/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">C++类型转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-09 21:47:23 / 修改时间：21:47:49" itemprop="dateCreated datePublished" datetime="2020-10-09T21:47:23+08:00">2020-10-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>&emsp;&emsp;C++中，类型转换大体上分为两种：隐式类型转换、显式类型转换</p>
<h2 id="1-隐式类型转换"><a href="#1-隐式类型转换" class="headerlink" title="1. 隐式类型转换"></a>1. 隐式类型转换</h2><p>&emsp;&emsp;隐式类型转换是编译器自动执行的，无需显式的操作符。隐式类型转换往往是安全的，并且带了便捷，但是可能产生意想不到的危险，因为很多时候甚至用户都不知道进行了哪些转换。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">int a = 3;
double b = 2.5;
a + b;                      //a会被隐式转换成double类型

void func(double a);
func(1);                    //1被隐式转换成了double类型1.0

double add(int a,int b)&#123;
  return a + b;            //运算结果会被隐式转换成double类型返回
&#125;

class A&#123;&#125;;
class B:public A&#123;&#125;;
void func(A& a);
B b;
func(b);                   //子类对象替代父类对象
</code></pre>
<p>&emsp;&emsp;这种数值类型的隐式转换，一般要满足低精度转换为高精度，否则会造成精读损失，影响最终结果。</p>
<p>&emsp;&emsp;为了提高代码的质量与可靠性，Google C++编程规范对隐式类型转换的建议为：可接受单个参数的构造函数必须加上explicit标记，禁止隐式类型转换。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class student&#123;
public:
  student();
  explicit student(int age)&#123;&#125;
&#125;;
</code></pre>
<h2 id="2-显式类型转换"><a href="#2-显式类型转换" class="headerlink" title="2. 显式类型转换"></a>2. 显式类型转换</h2><p>&emsp;&emsp;C风格的显式类型转换如下，但是不推荐使用，转化不明确，不能进行错误检查，容易出错。C++提供了4种强制类型转换操作符。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">TypeName x = (TypeName) y;         //C风格的类型转换
cast_name<type>(expression);       //C++风格的类型转换
</code></pre>
<p><strong>（1）static_cast</strong></p>
<pre class=" language-lang-C++"><code class="language-lang-C++">static_cast <new_type>(expression);     //使用方法

double x = 3.14159;
int a = static_cast<int>(x);            //一般来说，编译器隐式类型转换都可以用static_cast来转换
</code></pre>
<p>&emsp;&emsp;编写程序时需要明确的类型转换都可以使用static_cast，但是static_cast不能转换掉底层const，volatile和__unaligned属性。另外由于不提供运行时的检查，因此需要在编写程序时确认转换的安全性。</p>
<p><strong>使用场景：</strong></p>
<ol>
<li>用于类层次结构中，父类和子类之间指针和引用的转换；进行上行转换，把子类对象的指针/引用转换为父类指针/引用，这种转换是安全的；进行下行转换，把父类对象的指针/引用转换成子类指针/引用，这种转换是不安全的，需要编写程序时来确认</li>
<li>用于基本数据类型之间的转换，例如把int转char，int转enum等，需要编写程序时来确认安全性</li>
<li>把void指针转换成目标类型的指针（这是极其不安全的）</li>
</ol>
<p><strong>（2）const_cast</strong></p>
<pre class=" language-lang-C++"><code class="language-lang-C++">const_cast <new_type>(expression);        //使用方法，new_type必须为指针或引用

const char *pc;
char *p = const_cast<char*>(pc);
</code></pre>
<p>&emsp;&emsp;const_cast用于移除类型的const、volatile和_unaligned属性，其中new_type必须是一个指针、引用。也只有用const_cast才能移除const性质。</p>
<p><strong>使用场景：</strong></p>
<ol>
<li>常量指针被转换成非常量指针，并且仍然指向原来的对象</li>
<li>常量引用被转换成非常量引用，并且仍然引用原来的对象</li>
</ol>
<p><strong>（3）reinterpret_cast</strong></p>
<pre class=" language-lang-C++"><code class="language-lang-C++">reinterpret_cast<new_type>(expression);    //使用方法

int *ip;
char *pc = reinterpret_cast<char*>(ip);
</code></pre>
<p>&emsp;&emsp;功能非常强大，万物皆可转，如int转指针，但是容易出问题，建议少用</p>
<p><strong>（4）dynamic_cast</strong></p>
<pre class=" language-lang-C++"><code class="language-lang-C++">//new_type必须为类的指针、类的引用、void*
//如果new_type是指针类型，expression也必须是指针；new_type是引用，expression也必须是引用
dynamic_cast <new_type>(expression);
</code></pre>
<p>&emsp;&emsp;dynamic_cast只能用于有虚函数的类，<strong>dynamic_cast涉及运行时类型检查</strong>，具有一定的安全性，如果使用的类没有虚函数，如果绑定到引用或指针的对象的类型不是目标类型，都会出错。</p>
<ol>
<li>上行转换：子类向父类转换，非常安全</li>
<li>下行转换：父类向子类转换。</li>
</ol>
<pre class=" language-lang-C++"><code class="language-lang-C++">class A &#123; virtual void f()&#123;&#125;; &#125;;
class B : public A&#123; &#125;;
void main()
&#123;
     A* pA = new B;
     B* pB = dynamic_cast<B*>(pA); 
&#125;
</code></pre>
<ol>
<li>void*转换：有时候需要将指针转换为void*，在适合的时候将void*转换成目标类型指针</li>
</ol>
<pre class=" language-lang-C++"><code class="language-lang-C++">class A &#123; virtual void f()&#123;&#125; &#125;;
int main()
&#123;
     A *pA = new A;
     void *pV = dynamic_cast<void *>(pA); 
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dymzcc.github.io/2020/10/09/C++%EF%BC%9A3%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BA%8C%E4%B9%89%E6%80%A7%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dede">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三环三星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/09/C++%EF%BC%9A3%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BA%8C%E4%B9%89%E6%80%A7%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">继承方式以及二义性问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-09 21:44:23 / 修改时间：21:45:37" itemprop="dateCreated datePublished" datetime="2020-10-09T21:44:23+08:00">2020-10-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>&emsp;&emsp;C++中，一个派生类可以从一个基类派生，称为单继承，也可以从多个基类派生，称为多继承</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class <派生类名>:<继承方式> <基类名>&#123;        //单继承
  派生类新定义成员；
&#125;;
class <派生类名>:<继承方式1> <基类名1>，<继承方式2> <基类名2>&#123;      //多继承
  派生类新定义成员;
&#125;;
</code></pre>
<p>继承方式有3中：private、protected、public，3中继承方式下派生类对基类成员的访问权限如下：</p>
<p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/3种派生方式的访问权限.png" alt="3种派生方式的访问权限"></p>
<p>记住：无论哪种方式，基类中的私有成员都不允许派生类继承，即在派生类中不可见</p>
<p>&emsp;&emsp;派生类对基类成员的访问形式主要有以下两种：</p>
<p>（1）内部访问：由派生类中新增的成员函数对基类继承来的成员的访问</p>
<p>（2）对象访问：在派生类外部，通过派生类的对象对从基类继承来的成员的访问</p>
<h4 id="1-公有继承"><a href="#1-公有继承" class="headerlink" title="1. 公有继承"></a>1. 公有继承</h4><ol>
<li>父类的public成员成为子类的public成员，可以被子类中的函数及其友元函数访问（内部访问），还可以由该子类对象访问（外部访问）</li>
<li>父类的private成员仍是父类的private成员，子类成员不可访问，包括子类中的函数、友元函数、子类对象</li>
<li>父类的protected成员成为子类的protected成员，可以被子类中的函数及其友元函数访问，但是不可以由子类的对象访问</li>
</ol>
<p>&emsp;&emsp;在公有继承中，派生类的对象只能访问基类中的公有成员，派生类的成员函数可以访问基类中的公有成员和保护成员。</p>
<h4 id="2-私有继承"><a href="#2-私有继承" class="headerlink" title="2. 私有继承"></a>2. 私有继承</h4><p>&emsp;&emsp;私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所继承</p>
<h4 id="3-保护继承"><a href="#3-保护继承" class="headerlink" title="3. 保护继承"></a>3. 保护继承</h4><p>&emsp;&emsp;保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的</p>
<h2 id="二义性问题"><a href="#二义性问题" class="headerlink" title="二义性问题"></a>二义性问题</h2><h4 id="1-多基继承"><a href="#1-多基继承" class="headerlink" title="1. 多基继承"></a>1. 多基继承</h4><p>&emsp;&emsp;当继承基类时，在派生类中就获得了基类所有数据成员的副本，该副本称为子对象。如果一个派生类C继承了基类A和基类B，这时候类C就包含了A的子对象和B的子对象。假设基类A和基类B中有同名函数show()，这时候派生类调用show()时，编译器无法决定选择A中的show()还是B中的show()。</p>
<p>&emsp;&emsp;这时候可以使用作用域运算符来消除二义性，A::show()或这B::show()</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class A&#123;
public:
  void show()&#123;cout<<"A"<<endl;&#125;
&#125;;
class B&#123;
public:
  void show()&#123;cout<<"B"<<endl;&#125;
&#125;;
class C:public A,public B&#123;&#125;;
int main()&#123;
    C c;
  c.show();      //错误，直接调用，会有二义性
  c.A::show();   //正确，使用作用域运算符来消除二义性
&#125;
</code></pre>
<p>&emsp;&emsp;方法二，直接在派生类C中定义重名函数，用内层函数覆盖外层函数</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class C : public A,public B&#123;
public:
  void show()&#123;cout<<A::show()<<endl;&#125;
&#125;;
</code></pre>
<h4 id="2-菱形继承"><a href="#2-菱形继承" class="headerlink" title="2. 菱形继承"></a>2. 菱形继承</h4><p>&emsp;&emsp;如果派生类B和派生类C都是从相同的基类A派生而来，派生类D由类B和类C派生而来。类B和类C都包含了A的子对象，所以类D就会包含类A的两个子对象，即增加了存储空间又引入了二义性，虽然可以用B::show()这样的方法来解决一些问题，但是在调用基类A函数的时候，编译器就无法判断是调用类B还是类C继承的基类函数。</p>
<p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/菱形继承的二义性.png" alt="菱形继承的二义性" style="zoom: 33%;" /></p>
<p>&emsp;&emsp;这时候就要使用虚基类了，虚继承是一种机制，给定虚基类，不论该类在派生类中作为虚基类出现多少次，只继承一个共享的基类子对象，这样类D就只有一份A的子对象了。虚基类用virtual声明继承关系就行了。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class A&#123;&#125;;
class B : virtual public A&#123;&#125;;        //A是B的虚基类
class C : virtual public A&#123;&#125;;                 //A是C的虚基类
class D : public B,public C&#123;&#125;;             //D继承B和C，只继承A一次
</code></pre>
<p>&emsp;&emsp;虚基类只是解决了基类重复继承的问题，如果涉及到B和C中有同名成员造成的二义性问题，还是参考多重继承的方法去解决。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dymzcc.github.io/2020/10/09/%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dede">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三环三星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/09/%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB/" class="post-title-link" itemprop="url">运行时类型识别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-09 21:44:23 / 修改时间：21:46:27" itemprop="dateCreated datePublished" datetime="2020-10-09T21:44:23+08:00">2020-10-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><p>&emsp;&emsp;通过运行时类型识别（RTTI），程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际类型。</p>
<p>RTTI机制产生的原因：</p>
<p>&emsp;&emsp;C++本身是一种静态类型语言，数据类型是在编译期就确定的，在运行期间不能更改。但是在面向对象程序设计中，为了满足多态的需求，引入了动态联编，指针和引用本身的类型和它们指向或引用的对象的类型不一致。RTTI使得开发者在程序执行时，能够知道指针或者引用具体指向或引用的对象的类型。</p>
<p>&emsp;&emsp;RTTI有俩很有用的操作符，一个告诉你这个指针或引用的对象的类型，一个让你可以改改：</p>
<p>（1）typeid操作符：返回指针或引用所指对象的实际类型</p>
<p>（2）dynamic_cast操作符：将基类类型的指针或引用安全地转换为派生类型的指针或引用</p>
<h4 id="1-typeid"><a href="#1-typeid" class="headerlink" title="(1)typeid"></a>(1)typeid</h4><p>&emsp;&emsp;typeid(xxx)，其中xxx可以是任意表达式或者类型名。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">//对于C++的内置数据类型，typeid可以方便输出它们的数据类型
short s = 2;
char ch = 'a';
cout<<typeid(s)<<endl;     //short
cout<<typeid(ch)<<endl;    //char

//对于类和结构体，依然可以输出它们的数据类型
class A&#123;...&#125;;
struct B&#123;...&#125;;
A *pa = new A();
A a;
cout<<typeid(pa).name()<<endl;    // class A *
cout<<typeid(a).name()<<endl;     // class A

B *pb = new B();
B b;
cout<<typeid(pb).name()<<endl;    // struct B *
cout<<typeid(b).name()<<endl;     // struct B
</code></pre>
<p>&emsp;&emsp;注意，用基类类型指针指向派生类对象时：</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">//基类A中无虚函数
A *a = new B();
cout<<typeid(a).name()<<endl;      // class A *
cout<<typeid(*a).name()<<endl;     // class A

//基类A中有虚函数
A *a = new B();
cout<<typeid(a).name()<<endl;          // class A *
cout<<typeid(*a).name()<<endl;     // class B
</code></pre>
<pre class=" language-lang-C++"><code class="language-lang-C++">//typeid的应用：
A *a;
B *b;
if(typeid(*a)==typeid(*dp))&#123;      //比较两个所指对象的类型是否相同
  ....
&#125;
if(typeid(*a)==typeid(B))&#123;        //比较a是否指向B对象
  ....
&#125;
</code></pre>
<h4 id="（2）dynamic-cast"><a href="#（2）dynamic-cast" class="headerlink" title="（2）dynamic_cast"></a>（2）dynamic_cast</h4><p>&emsp;&emsp;将基类类型的指针或引用安全地转换为派生类型的指针或引用，即下行转换</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class A &#123; virtual void f()&#123;&#125;; &#125;;
class B : public A&#123; &#125;;
void main()
&#123;
     A* pA = new B;
     B* pB = dynamic_cast<B*>(pA); 
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dymzcc.github.io/2020/10/09/%E8%99%9A%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dede">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三环三星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/09/%E8%99%9A%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">虚函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-09 10:46:23 / 修改时间：21:47:12" itemprop="dateCreated datePublished" datetime="2020-10-09T10:46:23+08:00">2020-10-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-联编"><a href="#1-联编" class="headerlink" title="1. 联编"></a>1. 联编</h2><p>&emsp;&emsp;程序调用函数时，具体应使用哪个代码块是由编译器决定的，以函数重载为例，C++编译器根据传递给函数的参数和函数名决定具体使用哪一个函数，称为联编。</p>
<p>&emsp;&emsp;编译器在编译过程中完成这种联编，称为静态联编；在程序运行过程中完成联编，称为动态联编。</p>
<p>&emsp;&emsp;C++通过虚函数来实现动态联编。</p>
<h2 id="2-虚函数定义"><a href="#2-虚函数定义" class="headerlink" title="2. 虚函数定义"></a>2. 虚函数定义</h2><p>&emsp;&emsp;C++中，基类必须将它的两种成员函数分开：（1）基类希望派生类直接继承而不做改变的函数（2）基类希望派生类进行覆盖的函数。第二类函数通常就定义为虚函数。虚函数允许派生类重新定义与基类同名的成员函数，并且可以通过基类指针或者引用来访问基类和派生类中的同名函数</p>
<p>&emsp;&emsp;虚函数的定义很简单，只要在成员函数原型前加关键字virtual，如果一个基类的成员函数定义为虚函数，那它在派生类中也为虚函数，即使派生类中省略了virtual也仍是虚函数。</p>
<p>&emsp;&emsp;派生类中可以对虚函数重新定义，重新定义有以下要求：</p>
<ol>
<li>与基类的虚函数有相同的参数个数</li>
<li>与基类的虚函数有相同的参数类型</li>
<li>与基类的虚函数有相同的返回类型</li>
</ol>
<p>&emsp;&emsp;不能定义为虚函数的函数：（1）普通函数（非成员函数）（2）静态成员函数（3）构造函数（4）友元函数</p>
<h2 id="3-虚函数的访问"><a href="#3-虚函数的访问" class="headerlink" title="3. 虚函数的访问"></a>3. 虚函数的访问</h2><p><strong>（1）通过对象名访问</strong></p>
<p>&emsp;&emsp;通过对象名进行访问时，编译器采用的是静态联编，虚函数和普通函数一样，调用哪个类的函数决定于对象名的类型：对象类型是基类时，就调用基类的函数；对象类型时子类时，就调用子类的函数。</p>
<p><strong>（2）通过指针访问</strong></p>
<p>使用指针访问非虚函数：编译器根据指针的类型决定调用哪个函数，而不是根据指针所指对象的类型</p>
<p>使用指针访问虚函数：编译器根据指针所指对象类型决定调用哪个函数，而不是根据指针的类型</p>
<p><strong>（3）使用引用访问虚函数</strong></p>
<p>&emsp;&emsp;与使用指针访问虚函数类似，不同的是，引用一经声明后，引用变量本身无论如何改变，其调用的函数就不会改变，始终指向其开始定义的函数。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class A  
&#123;  
public:  
    void foo()  
    &#123;  
        printf("1\n");  
    &#125;  
    virtual void fun()  
    &#123;  
        printf("2\n");  
    &#125;  
&#125;;  
class B : public A  
&#123;  
public:  
    void foo()  //隐藏：派生类的函数屏蔽了与其同名的基类函数
    &#123;  
        printf("3\n");  
    &#125;  
    void fun()  //多态、覆盖
    &#123;  
        printf("4\n");  
    &#125;  
&#125;;  
int main(void)  
&#123;  
    A a;  
    B b;  
    A *p = &a;  
    p->foo();  //输出1
    p->fun();  //输出2
    p = &b;  
    p->foo();  //取决于指针类型，输出1
    p->fun();  //取决于对象类型，输出4，体现了多态
    return 0;  
&#125;
</code></pre>
<h2 id="5-虚函数的特性总结"><a href="#5-虚函数的特性总结" class="headerlink" title="5. 虚函数的特性总结"></a>5. 虚函数的特性总结</h2><ol>
<li>若在基类中，只是声明虚函数原型(需要加上virtual)，而在类外定义虚函数时，则不必再加上virtual</li>
<li>在派生类中重新定义时，其函数类型、函数名、参数个数、参数类型的顺序，都必须与基类中的原型完全相同</li>
<li>C++规定，当一个成员函数被定义为虚函数后，其派生类中符合重新定义虚函数要求的同名函数都自动称为虚函数。因此，在派生类中重新定义该虚函数时，关键字virtual可写可不写。但是为了程序更加清晰，最好在每一层派生类中定义函数时都加上关键字virtual</li>
<li>如果在派生类中没有对基类的虚函数重新定义，则公有派生类继承其直接基类的虚函数</li>
<li>一个虚函数无论被公有继承多少次。它仍然保持其虚函数的特性</li>
</ol>
<h2 id="6-虚函数与构造函数、析构函数"><a href="#6-虚函数与构造函数、析构函数" class="headerlink" title="6. 虚函数与构造函数、析构函数"></a>6. 虚函数与构造函数、析构函数</h2><p><strong>（1）构造函数不能为虚函数</strong></p>
<p>&emsp;&emsp;根据继承的性质，构造函数的执行顺序为：先父类的构造函数，再子类的构造函数。</p>
<p>&emsp;&emsp;根据虚函数的性质，如果父类的构造函数为虚函数，子类也有构造函数，则只执行子类的构造函数而不执行父类的构造函数。</p>
<p>&emsp;&emsp;二者冲突，因此构造函数不能为虚函数。</p>
<p><strong>（2）析构函数可以为虚函数</strong></p>
<p>&emsp;&emsp;在C++开发中，基类的析构函数一般都是虚函数。如果父类的析构函数不加virtual关键字，子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调用父类的析构函数，不会调用子类的析构函数；如果父类的析构函数加virtual关键字，子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调用子类的析构函数，再调用父类的析构函数。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class ClxBase
&#123;
    public:
        ClxBase() &#123;&#125;;
        virtual ~ClxBase() &#123; cout<<"delete ClxBase"<<endl; &#125;;

        virtual void DoSomething() &#123; cout << "Do something in class ClxBase!" << endl;  &#125;;

&#125;;

class ClxDerived : public ClxBase
&#123;
    public:
        ClxDerived() &#123;&#125;;
        ~ClxDerived() &#123; cout << "Output from the destructor of class ClxDerived!" << endl;  &#125;;

        void DoSomething() &#123; cout << "Do something in class ClxDerived!" << endl;  &#125;;

&#125;;

int main(int argc, char const* argv[])
&#123;
     ClxBase *pTest = new ClxDerived;        //父类指针指向子类对象
     pTest->DoSomething();
     delete pTest;       //如果父类析构函数不为虚函数，则此时只调用父类的构造函数，不会调用子类的构造函数，这时就会内存溢出
     return 0;
&#125;
</code></pre>
<p>&emsp;&emsp;这个之前也提到，如果使用指针访问非虚函数，编译器根据指针的类型决定调用哪个函数，而不是根据指针所指对象的类型，该指针是父类指针，delete该指针只会调用父类的析构函数。</p>
<p>&emsp;&emsp;那为什么用虚析构函数后，子类的析构函数也会调用？由于父类的析构函数为虚函数，所以子类会在所有属性前形成一张虚函数表，虚函数表里存储的就是父类的虚函数和自己定义覆盖了父类的虚函数。当delete父类的指针时，由于子类的析构函数与父类的析构函数构成多态，此时调用的函数由指针所指的对象决定，所以先执行子类的析构函数，再执行父类的析构函数。</p>
<p><strong>（3）构造函数和析构函数中的虚函数</strong></p>
<p>&emsp;&emsp;构造派生类对象时，先调用父类的构造函数，再调用派生类的构造函数。在执行父类的构造函数的这个过程中，对象的派生类部分是未初始化的，此时该对象是被认为是基类类型对象，当执行完派生类的构造函数后，才成为派生类对象。撤销派生类对象时也是一样。</p>
<p>&emsp;&emsp;如果在构造函数和析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本。</p>
<p>&emsp;&emsp;这种在构造函数和析构函数中调用虚函数的行为是非常不提倡的。</p>
<h2 id="7-重载、隐藏、覆盖"><a href="#7-重载、隐藏、覆盖" class="headerlink" title="7. 重载、隐藏、覆盖"></a>7. 重载、隐藏、覆盖</h2><p><strong>（1）重载</strong></p>
<p>重载的特性有：（1）相同的范围内，<strong>在同一个类中</strong>（2）函数名字相同（3）参数不同</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class A&#123;
public:
  int show(int a,intb)&#123;...&#125;
  void show(int a)&#123;...&#125;           
&#125;;
</code></pre>
<p><strong>（2）覆盖/重写</strong></p>
<p>覆盖的特性有：（1）不同的作用范围，分别位于基类和派生类（2）函数的名字相同（3）参数个数、类型相同（4）函数返回值相同（5）基类函数必须virtual</p>
<p><strong>（3）隐藏</strong></p>
<p>隐藏，是指派生类函数将基类函数给屏蔽了，只作用与派生类，其特性与覆盖不同：</p>
<ol>
<li>如果派生类的函数与基类的函数名相同，但是参数不同，此时不论有无virtual关键字，基类函数会被隐藏。</li>
<li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字，此时，基类的函数被隐藏。</li>
</ol>
<h2 id="8-虚函数原理"><a href="#8-虚函数原理" class="headerlink" title="8. 虚函数原理"></a>8. 虚函数原理</h2><p>&emsp;&emsp;虚函数是通过一张<strong>虚函数表</strong>实现的，虚函数表解决了继承、覆盖、添加虚函数的问题。如果一个类中有虚函数，那么该类就有一个虚函数表，所有该类的实例对象都会有一个虚函数表指针指向该类的虚函数表。</p>
<p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/虚函数表.png" alt="虚函数表" style="zoom: 40%;" /></p>
<p>&emsp;&emsp;只要基类有虚函数，那么子类就有虚函数表，而且基类的虚函数表和子类的虚函数表不是同一个表。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class A &#123;
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
&#125;;
class B : public A &#123;
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
&#125;;
class C: public B &#123;
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
&#125;;
</code></pre>
<p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/继承后的虚函数表.png" alt="继承后的虚函数表" style="zoom:40%;" /></p>
<p>&emsp;&emsp;注意图中，P是类A类型的指针，当它指向类B的一个对象时，它能访问的是类B中类A的部分，即黑框部分，因此该指针能访问类B对象中指向类B虚表的指针。</p>
<p>&emsp;&emsp;现在声明一个类A的指针p指向类B的对象b。虽然p是基类的指针，只能指向基类的部分，但是虚表指针也属于基类部分，因此p可以访问到对象b的虚表指针，b的虚表指针指向类B的虚表，所以p可以访问到类B的虚函数表。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">B b;
A *p = &b;
p->vfunc1();
</code></pre>
<p>&emsp;&emsp;此时使用p来调用vfun1()函数，p访问对象b的虚表指针，然后在虚表中查找对应条目，找到指向B::func1()函数。</p>
<p>&emsp;&emsp;现在声明一个类A类型的指针指向类A的对象a，使用p来调用vfunc1()，p访问对象a的虚表指针，从而访问类A对应的虚表，在该虚表中查找对应条目，找到指向A::vfunc1()函数。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">A a;
A *p = &a;
p->vfunc1();
</code></pre>
<h2 id="9-纯虚函数"><a href="#9-纯虚函数" class="headerlink" title="9. 纯虚函数"></a>9. 纯虚函数</h2><p>&emsp;&emsp;纯虚函数是一种特殊的虚函数，其格式如下：</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class 类名&#123;
  virtual 类型 函数名(参数表)=0;
  ...
&#125;；
</code></pre>
<p>&emsp;&emsp;在基类中不能对虚函数给出有意义的实现时，可以将它声明为纯虚函数，将它的实现留给派生类去实现。就好像基类是动物，派生类可以有猴子、老虎、孔雀等等，猴子这些都可以有实体对象，但是基类动物本身生成对象就不合理。</p>
<p>&emsp;&emsp;<strong>凡是有纯虚函数的类称为抽象类</strong>，这种类不能声明，不能实例化对象，只是作为基类为派生类服务。只有当<strong>派生类实现了基类的所有纯虚函数</strong>，派生类才可以实例化对象，否则派生类也是抽象类。</p>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75172640">https://zhuanlan.zhihu.com/p/75172640</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36359022/article/details/81870219?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.edu_weight">https://blog.csdn.net/qq_36359022/article/details/81870219?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.edu_weight</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dymzcc.github.io/2020/10/07/static%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dede">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三环三星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/07/static%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">static关键字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-07 14:40:23 / 修改时间：14:41:08" itemprop="dateCreated datePublished" datetime="2020-10-07T14:40:23+08:00">2020-10-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-面向对象的静态成员变量"><a href="#1-面向对象的静态成员变量" class="headerlink" title="1. 面向对象的静态成员变量"></a>1. 面向对象的静态成员变量</h4><p>&emsp;&emsp;在类内成员变量的声明前加上关键字static，该数据成员就是类内的静态数据成员。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class A&#123;
  static int num;     //声明静态数据成员
  ...
&#125;
int A::num = 0;       //类外定义并初始化静态数据成员，此时不加static
</code></pre>
<p><strong>静态成员变量的特点：</strong></p>
<ol>
<li>静态成员变量是该类的所有对象所共有的，静态成员变量定义在全局（静态）存储区，不属于特定的类对象，也不占对象的内存</li>
<li>在类的实例没有生成时，静态成员变量就已经存在，可以通过A::num就能访问</li>
<li>静态成员变量存储在全局（静态）存储区，static成员变量的内存是在初始化的时候分配的，因此静态成员变量必须初始化，而且只能在类体外进行。</li>
<li>静态成员变量的访问方式：（1）类名::静态数据成员名（2）类对象名.静态数据成员名</li>
<li>静态数据成员和普通数据成员一样遵从public、protected、private访问规则</li>
<li>sizeof运算符不会计算静态成员变量</li>
</ol>
<p><strong>静态数据成员的作用：</strong></p>
<ol>
<li>把所有对象共享的成员分配在全局（静态）存储区，节省了存储空间</li>
<li>一变多变，只需要改变一次，就能改变所有对象的相应的值</li>
</ol>
<p><strong>与全局变量相比：</strong></p>
<ol>
<li>静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能</li>
<li>可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能</li>
</ol>
<h4 id="2-面向对象的静态成员函数"><a href="#2-面向对象的静态成员函数" class="headerlink" title="2. 面向对象的静态成员函数"></a>2. 面向对象的静态成员函数</h4><p>&emsp;&emsp;在类内成员函数声明前加static，该成员函数就是静态成员函数。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class sutdent&#123;
public:
  int score;
  static int num;
  static int sum
  static int ave();
  student(int score)&#123;
    this->score = score;
    num++;
    sum+=score;
  &#125;
&#125;
int student::num=0;
int student::sum=0;
int ave()&#123;
  return sum/num;
&#125;
</code></pre>
<p><strong>静态成员函数的特点：</strong></p>
<ol>
<li>静态成员函数属于类本身，属于类定义的一部分，不具体作用于类的某个特定对象，在类的对象实例化前已存在，可以通过类名访问</li>
<li>普通成员函数隐含一个this指针，指向类的对象本身。而静态成员函数不作用于具体对象，因此不存在this指针</li>
<li>声明在类内，定义并初始化在类外，且类外定义时不加static</li>
<li>静态成员函数可以访问静态成员函数、静态成员变量，不能访问非静态成员函数、非静态成员变量；非静态成员函数可以任意访问</li>
<li>调用静态成员函数方法：（1）对象名.静态成员函数名（参数表）；对象名-&gt;静态成员函数名（参数表）（2）类名::静态成员函数名（参数表）</li>
</ol>
<h4 id="3-面向过程的静态全局变量"><a href="#3-面向过程的静态全局变量" class="headerlink" title="3. 面向过程的静态全局变量"></a>3. 面向过程的静态全局变量</h4><p>&emsp;&emsp;在全局变量前，加上关键字static，该变量就被定义成一个静态全局变量</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">static int n;        //定义静态全局变量
void fn()&#123;
    n++;
    cout<<n<<endl;
&#125; 
void main()&#123;
  n = 20;
  cout<<n<<endl;
  fn();
&#125;
</code></pre>
<p><strong>静态全局变量的作用：</strong></p>
<ol>
<li>静态全局变量不能被其它文件所用</li>
<li>其它文件中可以定义相同名字的变量，不会发生冲突</li>
</ol>
<h4 id="4-面向过程的静态局部变量"><a href="#4-面向过程的静态局部变量" class="headerlink" title="4. 面向过程的静态局部变量"></a>4. 面向过程的静态局部变量</h4><p>&emsp;&emsp;在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">void fn()&#123;
  static n = 10;
  cout<<n<<endl;
  n++;
&#125;
void main()&#123;
  fn();           //10
  fn();                        //11
  fn();                        //11
&#125;
</code></pre>
<p>&emsp;&emsp;通常在函数体内定义一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存，但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。</p>
<p>&emsp;&emsp;静态局部变量保存在全局（静态）存储区，而不是保存在栈内，每次的值可以保持到下一次调用，直到下次赋值。</p>
<p><strong>静态局部变量特点：</strong></p>
<ol>
<li>静态局部变量在全局数据区分配内存</li>
<li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化</li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0</li>
<li>静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束</li>
</ol>
<h4 id="5-面向过程的静态函数"><a href="#5-面向过程的静态函数" class="headerlink" title="5. 面向过程的静态函数"></a>5. 面向过程的静态函数</h4><p>&emsp;&emsp;在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">static void fn()&#123;        //定义静态函数
  int n = 10;
  cout<<n<<endl;
&#125;
</code></pre>
<p><strong>静态函数的作用：</strong></p>
<ol>
<li>静态函数不能被其它文件所用；</li>
<li>其它文件中可以定义相同名字的函数，不会发生冲突；</li>
</ol>
<h4 id="6-全局变量、局部变量、静态全局变量、静态局部变量"><a href="#6-全局变量、局部变量、静态全局变量、静态局部变量" class="headerlink" title="6. 全局变量、局部变量、静态全局变量、静态局部变量"></a>6. 全局变量、局部变量、静态全局变量、静态局部变量</h4><p>C++中作用域可分为6种：全局作用域、局部作用域、语句作用域、类作用域、命名空间作用域、文件作用域</p>
<p><strong>（1）从作用域角度看不同：</strong></p>
<p>&emsp;&emsp;全局变量具有全局作用域，只要在一个文件中定义，就可以作用于所有的文件，不过其他文件中需要extern声明这个全局变量</p>
<p>&emsp;&emsp;局部变量具有局部作用域，只在函数执行期间存在，函数的一次调用结束后，变量撤销，该内存也销毁</p>
<p>&emsp;&emsp;静态全局变量具有全局作用域，它只作用于定义它的文件里，不能作用到其他文件</p>
<p>&emsp;&emsp;静态局部变量具有局部作用域，它只被初始化一次，然后到程序结束一直存在。全局变量是对所有的函数都是可见的，静态局部变量支队定义自己的函数始终可见</p>
<p><strong>（2）从分配内存角度看不同</strong></p>
<p>&emsp;&emsp;全局变量、静态全局变量、静态局部变量都存储在全局（静态）存储区中，局部变量存储在栈中</p>
<p><strong>（3）Tips：</strong></p>
<ol>
<li>若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度</li>
<li>若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度</li>
</ol>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37439983">https://zhuanlan.zhihu.com/p/37439983</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/note/36010">https://www.runoob.com/note/36010</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dymzcc.github.io/2020/10/07/const%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dede">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三环三星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/07/const%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">const关键字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-07 12:01:23 / 修改时间：12:02:55" itemprop="dateCreated datePublished" datetime="2020-10-07T12:01:23+08:00">2020-10-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-基本数据类型与const"><a href="#1-基本数据类型与const" class="headerlink" title="1. 基本数据类型与const"></a>1. 基本数据类型与const</h4><p>（1）const修饰变量，含义是const修饰的对象的值不可变</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">int const age = 20;
const int age = 20;
</code></pre>
<p>（2）const的对象是文件局部变量，只能用于本编译模块，使用extern const声明该常量可以作用于其他编译模块，即被其他文件访问</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">extern const int age = 20;
//extern用于告诉编译器存在着一个变量或者函数，当前编译语句前如果没有定义的话，那么该变量或者函数定义在文件的后头或者其它文件中，即提示编译器遇到此变量和函数时在其他模块中寻找其定义。
</code></pre>
<h4 id="2-指针与const"><a href="#2-指针与const" class="headerlink" title="2. 指针与const"></a>2. 指针与const</h4><p>（1）指针本身是常量，所指对象不可变，但是对象的值可以变，这种指针在声明时必须初始化</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">int c = 20;
int* const age = &c;
</code></pre>
<p>（2）指针指向的内容是常量，不可变</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">const int* age;
</code></pre>
<p>（3）二者都不可变</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">int c = 20;
const int* const age = &c;
</code></pre>
<p>如果const位于*的右侧，指针本身是常量</p>
<p>如果const位于*的左侧，指针指向常量；</p>
<h4 id="3-引用与const"><a href="#3-引用与const" class="headerlink" title="3. 引用与const"></a>3. 引用与const</h4><p>&emsp;&emsp;const引用就是指向const对象的引用，普通引用无法绑定到const对象上，但const引用可以绑定到非const对象上</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">int var1 = 1, var2 = 2;
int &a = 0;                                     // 一般引用无法绑定到字面值常量
const int &b = 0;                         //const引用可以绑定字面常量值
int &c = var1 + var2;                 //错误，左值引用不可绑定右值
const int &d = var1 + var2;     //const引用可以绑定右值
</code></pre>
<h4 id="4-函数与const"><a href="#4-函数与const" class="headerlink" title="4. 函数与const"></a>4. 函数与const</h4><p>（1）const修饰函数的参数</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">void function(const int var);         //传递过来的参数在函数内无法改变，无意义，因为var本来就是形参

void function(const int* var);        //参数指针所指内容为常量，不可变

void function(int* const var);        //参数指针本身为常量，不可变，也无意义，因为指针也是形参

void function(const int& var);        //引用参数在函数内为常量不可变
</code></pre>
<p>（2）const修饰函数返回值，令函数返回值为一个常量</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">const int fun1();             //无意义，参数返回本身就是赋值
const int* fun2();            //指针指向函数，指针内容不可变
int* const fun3();            //指针指向函数，指针本身不可变
</code></pre>
<h4 id="5-类与const"><a href="#5-类与const" class="headerlink" title="5. 类与const"></a>5. 类与const</h4><p>（1）const修饰成员变量，表示成员常量，不能被修改，只能在初始化列表中赋值</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class A&#123;
  const int age;            //成员常量不能被修改，只能在初始化的时候赋值
  ...
  A(int x):age(x)&#123;&#125;;
&#125;
</code></pre>
<p>（2）const修饰成员函数，它不改变对象的成员变量. 也不能调用类中任何非const成员函数</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">void getAge()const;           //该成员函数无法改变类成员变量的值，在不改变类的值的函数后面加上const，养成习惯
</code></pre>
<p>（3）const修饰类的对象，该对象只能调用类内const成员函数，另外类内任何成员都不能改变</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class A
&#123;
public:
    A()&#123;cout << "non-const" << endl;&#125;
    void test() const&#123;cout << "const" << endl;&#125; 
&#125;;

int main(int argc, char *argv[])
&#123;
    const A a1;
    a1.test();                     //只能调用const成员函数
    return 0;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dymzcc.github.io/2020/10/07/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dede">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三环三星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/07/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">内存分配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-07 10:26:23 / 修改时间：20:32:16" itemprop="dateCreated datePublished" datetime="2020-10-07T10:26:23+08:00">2020-10-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-内存分区"><a href="#1-内存分区" class="headerlink" title="1. 内存分区"></a>1. 内存分区</h4><p><strong>（1）堆：</strong>由程序员手动分配和释放，完全不同于数据结构中的堆，分配方式类似链表。由malloc或new来分配，由free或delete释放。如果程序员不释放，程序结束时由系统释放。</p>
<p><strong>（2）栈：</strong>由编译器自动分配和释放，存放函数的参数值、局部变量的值等。操作方式类似数据结构中的栈。</p>
<p><strong>（3）全局（静态）存储区：</strong>存放全局变量和静态变量。包括两部分：DATA段（全局初始化区）和BSS段（全局未初始化区）。初始化后的全局变量和静态变量存放在DATA段，未初始化的全局变量和未初始化的静态变量存放在BSS段。程序结束后由系统释放。另外，BSS段在程序执行之前会自动清0，因此未初始化的全局变量和静态变量在程序执行之前会变成0。</p>
<p><strong>（4）文字常量区：</strong>常量字符串就是放在这里，程序结束后由系统释放。</p>
<p><strong>（5）程序代码区：</strong>存放函数体的二进制代码。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">int  a=0;   全局初始化区    

char *p1;   全局未初始化区    
int  main()    
&#123;    
  int  b;                                 //栈    
  char  s[]="abc";                 //栈    
  char  *p2;                             //栈    
  char  *p3="123456";         //123456/0在常量区，p3在栈上。    

  static int c =0；                        //全局（静态）初始化区    
  p1 =  (char  *)malloc(10);  //分配得来得10和20字节的区域就在堆区
  p2  = (char  *)malloc(20);       
  strcpy(p3,"123456"); //123456/0放在常量区，编译器可能会将它与p3所指向的"123456"  优化成一个地方。    
&#125;
</code></pre>
<h4 id="2-堆和栈的区别"><a href="#2-堆和栈的区别" class="headerlink" title="2. 堆和栈的区别"></a>2. 堆和栈的区别</h4><p><strong>（1）管理方式</strong></p>
<p>&emsp;&emsp;栈由编译器自动管理，无需手工控制；堆由程序员控制，如果不释放会内存溢出。</p>
<p><strong>（2）空间大小</strong></p>
<p>&emsp;&emsp;堆内存大，32位系统下，堆内存可以达到4G；栈有一定的空间大小，2M还是1M，反正不大，且编译时确定了</p>
<p><strong>（3）碎片问题</strong></p>
<p>&emsp;&emsp;对于堆来说，频繁的new/delete会造成内存空间的不连续，产生大量碎片，使程序效率降低；对于栈来说，栈是先进后出的丢列，不会有内存块从栈中间弹出，因此不会造成内存空间不连续。</p>
<p><strong>（4）生长方向：</strong></p>
<p>&emsp;&emsp;堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。栈的动态分配由 alloca 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>
<p><strong>（5）分配效率：</strong></p>
<p>&emsp;&emsp;栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p>
<p><strong>（6）申请后系统的响应</strong></p>
<p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<p><strong>（7）堆和栈中的存储内容</strong></p>
<p>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。<br>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013007900/article/details/79338653">https://blog.csdn.net/u013007900/article/details/79338653</a></p>
<p>《王道程序员面试宝典》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dymzcc.github.io/2020/10/07/%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E4%B8%8E%E8%BD%AC%E7%A7%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dede">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三环三星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/07/%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E4%B8%8E%E8%BD%AC%E7%A7%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">右值与转移构造函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-07 09:46:23 / 修改时间：09:48:08" itemprop="dateCreated datePublished" datetime="2020-10-07T09:46:23+08:00">2020-10-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-左值、右值、左值引用、右值引用"><a href="#1-左值、右值、左值引用、右值引用" class="headerlink" title="1. 左值、右值、左值引用、右值引用"></a>1. 左值、右值、左值引用、右值引用</h4><p>左值：它表示一个可被标识的（变量或对象的）内存位置，并且允许使用&amp;操作符来获取这块内存的地址</p>
<p>右值：如果一个表达式不是左值，那就是右值</p>
<p>左值引用：对一个左值进行引用的类型，声明符号为”&amp;”</p>
<p>右值引用：对一个右值进行引用的类型，声明符号为”&amp;&amp;”，右值通常不具有名字，因此只能通过引用的方式找到它的存在</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">int a;
int &ref_a = a;         //左值引用

int&& get();                //右值引用
const int& val = get();     //也可以用const的左值引用来绑定一个右值
</code></pre>
<p>右值引用的意义：</p>
<ul>
<li>为临时变量续命，右值会在表达式结束后消亡，如果继续使用右值，就会调用昂贵的拷贝构造函数</li>
<li>右值引用是用来支持转移语义的，通过转移语义，临时对象中的资源能够转移到其他对象里（转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多）</li>
</ul>
<h4 id="2-转移构造函数"><a href="#2-转移构造函数" class="headerlink" title="2. 转移构造函数"></a>2. 转移构造函数</h4><p>&emsp;&emsp;假设已经实现了类MyClass：</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">MyClass fn();                                    // 返回MyClass对象的函数
MyClass foo;                                    // 调用默认的构造函数
MyClass bar = foo;                        // 调用Copy构造函数
MyClass baz = fn();                        // 调用Move构造函数
foo = bar;                                        // 调用Copy赋值操作符
baz = MyClass();                            // 调用Move赋值操作符
</code></pre>
<p>&emsp;&emsp;函数fn()返回的对象和MyClass构造的对象都是非命名的临时对象，之前一般的操作是将该临时对象复制，然后摧毁临时对象。但是如果使用转移语义，就可以避免复制操作同时节省空间</p>
<p>&emsp;&emsp;转移构造函数中只是对传进来的对象进行了所有权的转让，即掏空传进来的对象，然后把所有权转给当前对象（this指针指向的那个对象）</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class MyString &#123; 
private: 
 char* _data; 
 size_t   _len; 
 void _init_data(const char *s) &#123; 
   _data = new char[_len+1]; 
   memcpy(_data, s, _len); 
   _data[_len] = '\0'; 
 &#125; 
public: 
 MyString() &#123;                                 //默认构造函数
   _data = NULL; 
   _len = 0; 
 &#125; 

 MyString(const char* p) &#123;                    //拷贝构造函数
   _len = strlen (p); 
   _init_data(p); 
 &#125; 
 //注意：传入参数（右值）的资源链接和标记就会修改，否则右值的析构函数就会释放资源，转移到新对象的资源也就无效了
MyString(MyString&& str) &#123;                       //转移构造函数
   _len = str._len; 
   _data = str._data; 
   str._len = 0; 
   str._data = NULL; 
&#125;

MyString& operator=(MyString&& str) &#123;          //转移赋值操作符
   if (this != &str) &#123; 
     _len = str._len; 
     _data = str._data; 
     str._len = 0; 
     str._data = NULL; 
   &#125; 
   return *this; 
&#125;

virtual ~MyString() &#123; 
   if (_data) free(_data); 
 &#125; 
&#125;; 

int main() &#123; 
 MyString a; 
 a = MyString("Hello"); 
 MyString b = MyString("Test");       
 std::vector<MyString> vec; 
 vec.push_back(MyString("World")); 
&#125;
</code></pre>
<p>&emsp;&emsp;MyString(“Hello”) 和 MyString(“World”) 都是临时对象，也就是右值。虽然它们是临时的，但程序仍然调用了拷贝构造和拷贝赋值，造成了没有意义的资源申请和释放的操作。如果能够直接使用临时对象已经申请的资源，既能节省资源，有能节省资源申请和释放的时间。这正是定义转移语义的目的。</p>
<p>注意：C++编译器对调用转移构造函数的情况进行优化，即返回值优化，如果函数的返回值被用于初始化另外一个对象，这种情况下，不会调用转移构造函数，会直接调用构造函数。</p>
<h4 id="3-std-move"><a href="#3-std-move" class="headerlink" title="3. std::move"></a>3. std::move</h4><p>&emsp;&emsp;所有的命名对象都是左值引用，而编译器只对右值引用才会调用转移语义。如果能够确定一个命名对象将不再被使用，就可以对它调用转移语义，也就是把一个左值当作右值引用来使用。为了实现这种用法，C++标准库提供了函数std::move，这个函数将左值引用转为右值引用。</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">template <class T> swap(T& a, T& b) &#123;
    T tmp(a);    //copy a to tmp
    a = b;        //copy b to a
    b = tmp;    //copy tmp to b
&#125;

//通过使用std::move避免了3次不必要的拷贝操作
template <class T> swap(T& a, T& b) &#123;
    T tmp(std::move(a));    //move a to tmp
    a = std::move(b);         //move b to a
    b = std::move(tmp);        //move tmp to b
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dymzcc.github.io/2020/10/06/new:delete/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dede">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三环三星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/06/new:delete/" class="post-title-link" itemprop="url">new/delete和malloc/free</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-06 19:19:23" itemprop="dateCreated datePublished" datetime="2020-10-06T19:19:23+08:00">2020-10-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-07 10:11:48" itemprop="dateModified" datetime="2020-10-07T10:11:48+08:00">2020-10-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-malloc-free"><a href="#1-malloc-free" class="headerlink" title="1. malloc/free"></a>1. malloc/free</h4><p>&emsp;&emsp;在C语言中，需要动态开辟内存时，可以调用malloc函数()，从堆里获得空间，即malloc函数返回指向堆里面一块内存的指针。操作系统中有一个记录空闲内存地址的链表，如果收到获取内存空间的请求，就会遍历这个链表，找到第一个空间大于申请空间的堆结点，然后将该节点从链表中删除，并返回指向该空间的指针。</p>
<p>&emsp;&emsp;在使用malloc分配内存空间后，一定要使用free()函数释放内存空间，否则就会内存泄露。另外，free()释放的是内存空间，并没有释放指向该空间的指针，如果不在释放内存后将该指针指向NULL，就会形成悬空指针。</p>
<h4 id="2-内部数据对象和非内部数据对象"><a href="#2-内部数据对象和非内部数据对象" class="headerlink" title="2. 内部数据对象和非内部数据对象"></a>2. 内部数据对象和非内部数据对象</h4><p>&emsp;&emsp;简单来说：内部数据对象就是编译器本来就认识的，不需要用户自己定义；非内部数据类型不是编译器本来就认识的，需要用户自己定义才能让编译器识别。</p>
<p>&emsp;&emsp;malloc/free是标准库函数，只负责分配内存，编译器不会对其进行编译检查。类的对象的生成和消亡需要分别调用构造函数和析构函数，需要编译器进行编译检查，因此malloc/free无法执行构造函数和析构函数。因此引入new/delete运算符。</p>
<h4 id="3-new-delete"><a href="#3-new-delete" class="headerlink" title="3. new/delete"></a>3. new/delete</h4><p>&emsp;&emsp;new/delete是操作符，与”+”、”-“一样，与malloc/free类似，可以用于申请动态内存和释放内存。</p>
<p>（1）当使用new动态申请内存时：首先调用operator new标准库函数，据说这个标准库函数的底层实际上还是malloc，传入的参数为目标对象的大小；此时申请到的内存时未初始化的，接着就在这块内存上调用相应的构造函数；最后一步返回新分配并构造好的对象的指针</p>
<p>（2）当使用delete释放内存时：调用对象的析构函数，然后调用operator delete标准库函数来释放该内存，同样据说这个标准库函数的底层实际上是free，传入的参数为对象的地址值</p>
<pre class=" language-lang-C++"><code class="language-lang-C++">class A *p = new A(10);        //创建一个类的对象，返回其指针
delete p;                      //释放该内存
*p->NULL;                      //指向NULL
</code></pre>
<p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/new:delete.png" alt="new:delete" style="zoom:50%;" /></p>
<h4 id="5-二者的区别"><a href="#5-二者的区别" class="headerlink" title="5. 二者的区别"></a>5. 二者的区别</h4><p><strong>本质区别：</strong>new/delete是操作符，与”+”、”-“一样，malloc/free是标准库函数。</p>
<p><strong>操作对象范围不同：</strong>new操作是分三步的：第一步申请内存，第二步调用构造函数初始化对象，第三步返回指向该对象的指针。delete操作同样：第一步调用析构函数，第二步销毁堆内存。对于这样需要调用构造函数和析构函数的对象来说，malloc/free无法满足要求。换言之 ， 对于非内部数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free 。</p>
<p><strong>用法不同：</strong>（1） new能够按照变量类型自动地分配所需空间长度，不必使用宏sizeof（2）new能够自动返回正确的指针类型（3）必须时，new能将单个变量初始化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dymzcc.github.io/2020/09/12/Overlapping%20Community%20Detection%20Based%20on%20Random%20Walk%20and%20Seeds%20Extension/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dede">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三环三星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/Overlapping%20Community%20Detection%20Based%20on%20Random%20Walk%20and%20Seeds%20Extension/" class="post-title-link" itemprop="url">Overlapping Community Detection Based on Random Walk and Seeds Extension</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 10:19:23" itemprop="dateCreated datePublished" datetime="2020-09-12T10:19:23+08:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-06 21:00:20" itemprop="dateModified" datetime="2020-10-06T21:00:20+08:00">2020-10-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Overlapping-Community-Detection-Based-on-Random-Walk-and-Seeds-Extension"><a href="#Overlapping-Community-Detection-Based-on-Random-Walk-and-Seeds-Extension" class="headerlink" title="Overlapping Community Detection Based on Random Walk and Seeds Extension"></a>Overlapping Community Detection Based on Random Walk and Seeds Extension</h1><h2 id="种子拓展的局部社区发现算法"><a href="#种子拓展的局部社区发现算法" class="headerlink" title="种子拓展的局部社区发现算法"></a>种子拓展的局部社区发现算法</h2><p>&emsp;&emsp;全局的社区发现方法有：层次聚类算法，谱方法，基于团的方法，边聚类，标签传播等。</p>
<p>&emsp;&emsp;全局的社区发现需要对整个网络结构信息进行整体认知，在规模不大或者不完整的复杂网络中就会存在一些缺陷，所以就有人提出了基于种子拓展的局部社区发现方法。</p>
<p>&emsp;&emsp;基于种子拓展的局部社区发现算法通常是从网络的种子节点出发，利用社区的局部信息不断的从网络中加入节点来发现社区结构。</p>
<h2 id="SEOCD"><a href="#SEOCD" class="headerlink" title="SEOCD"></a>SEOCD</h2><p>&emsp;&emsp;为了能够准确的发现网络中的重叠社区结构，本文提出了基于随机游走和种子拓展的重叠社区发现算法（SEOCD）。在种子选取阶段，采用随机游走 $t$ 步之后最有可能返回自身的节点作为种子，根据节点和社区的相似度找出种子邻居集中相似度大于设定阈值的节点，与种子节点一起构成紧密的种子社区。</p>
<h4 id="1-概念介绍"><a href="#1-概念介绍" class="headerlink" title="1. 概念介绍"></a>1. 概念介绍</h4><p>&emsp;&emsp;$G(V,E)$表示图或者网络，$V$为点集，$E$为边集，$n=|V|$表示节点数，$m=|E|$表示边数。</p>
<p><strong>定义1：</strong>转移概率矩阵$p_{uv}$</p>
<script type="math/tex; mode=display">
p_{uv}=A_{uv}/k_v
\tag{1}</script><p>&emsp;&emsp;式中，$A_{uv}$为邻接矩阵，$k_v$为节点$v$的度。$p_{uv}$表示节点$u$随机游走一步到达节点$v$的概率，随机游走$t$步后的转移概率矩阵为$p_{uv}^t$。</p>
<p><strong>定义2</strong>：评分矩阵B：</p>
<script type="math/tex; mode=display">
B=\sum_{t=1}^Tp_{uv}^t
\tag{2}</script><p>&emsp;&emsp;评分矩阵$B$中每个元素代表节点$u$走$t$步后到达节点$v$所得到的评分，用$B(u,v)$表示，若两个节点连接越紧密，其评分越高。</p>
<p><strong>定义3：</strong>社区邻居集$NBSet(C_i)$表示与社区$C_i$有连接边的节点集合：</p>
<script type="math/tex; mode=display">
NBSet(C_i)=\bigcup_{v\in C_i}\Gamma(v)
\tag{3}</script><script type="math/tex; mode=display">
\Gamma(v)=\{u:u\in V,(v,u)\in E\}
\tag{4}</script><p>&emsp;&emsp;式中，$C_i$表示一个社区，$\Gamma(v)$表示节点$v$的邻域集合。</p>
<p><strong>定义4：</strong>节点$v$与社区$C_i$相似度$NC_SIM(v,C_i)$：</p>
<script type="math/tex; mode=display">
NC\_SIM(v,C_i)=\frac{k_v^{C_i}}{k_v}
\tag{5}</script><p>&emsp;&emsp;式中，$k_v^{C_i}$表示节点$v$与社区$C_i$关联边的度，$k_v$为节点$v$的度，$NC_SIM(v,C_i)$越大，节点$v$越有可能属于社区$C_i$。</p>
<p><strong>定义5：</strong>社区$C_i$和社区$C_j$的相似度$CC_SIM(C_i,C_j)$定义为：</p>
<script type="math/tex; mode=display">
CC\_SIM(C_i,C_j)=\frac{|overlap(C_i,C_j|}{min(|C_i|,|C_j|)}
\tag{6}</script><p>&emsp;&emsp;式中，$|overlaop(C_i,C_j)|$表示社区$C_i$和$C_j$共有的节点数，$|C_i|$表示社区$C_i$的节点数。$CC_SIM(C_i,C_j)$越大，表示两个社区结构越相近，当超过一个阈值$\varepsilon$时，则需合并两个社区。</p>
<p><strong>定义6：</strong>自适应函数用于衡量一组节点的紧密程度，具体公式定义如下：</p>
<script type="math/tex; mode=display">
f_{\rm g}=\frac{k_{in}^{\rm g}}{(k_{in}^{\rm g}+k_{out}^{\rm g})^{\alpha}}
\tag{7}</script><p>&emsp;&emsp;式中：$k_{in}^{\rm g}$和$k_{out}^{\rm g}$为子图$\rm g$内部度和外部度的总值，参数$\alpha$是一个正实数，用于控制发现的社区的规模。</p>
<h4 id="2-SEOCD算法的实现"><a href="#2-SEOCD算法的实现" class="headerlink" title="2. SEOCD算法的实现"></a>2. SEOCD算法的实现</h4><p>&emsp;&emsp;基于随机游走与种子拓展重叠社区发现算法（Seeds Extension Overlapping Community Detection，SEOCD）核心步骤为检测种子社区和社区拓展挖掘。在种子社区检测阶段，采用随机游走的策略找到初始种子，然后选择与种子紧密相连的邻居节点一起构成种子社区；在社区拓展阶段，利用局部节点和邻居节点相关信息，取具有最大相似度且能够优化局部自适应函数的节点来加入社区，以实现整个网络的社区划分。由于每个种子社区都是沿其邻居集独立进行社区拓展，因此可以发现重叠社区。</p>
<p>&emsp;&emsp;SEOCD算法分为4个阶段：（1）种子社区检测（2）相似种子社区合并（3）社区拓展挖掘（4）社区优化</p>
<p><strong>（1）种子社区检测</strong></p>
<p>&emsp;&emsp;首先计算每个节点$v$随机游走$t$步后回到自身的评分值$B(u,v)$，按评分值排序，选择最高的$l$个节点作为初始种子，然后按公式（5）找出初始种子社区邻居集中与种子社区相似度$NC_SIM$大于阈值$\varepsilon$的节点，与$v$合并得到社区$S$。</p>
<p><strong>（2）相似种子社区合并</strong></p>
<p>&emsp;&emsp;在检测种子社区阶段，由于是基于整个网络选取的种子构成种子社区，可能会出现两个种子社区的相似度高的情况，因此需要将其合并。根据公式（6）计算社区之间相似度$CC_SIM(C_i,C_j)$，如果相似度大于阈值$\varepsilon$，则合并两个种子社区。</p>
<p><strong>（3）社区拓展挖掘</strong></p>
<p>&emsp;&emsp;得到稳定紧密的种子社区后，从种子社区出发进行社区拓展挖掘：首先遍历种子社区的邻居集$NBSet$，根据公式（5）计算每个邻居节点和社区的相似度，取前面$l$个最高相似度的种子，然后计算这些节点加入局部社区后的自适应函数值，把能够让自适应函数值增加的节点加入到社区，否则就将其设置为自由节点，同时删除社区中让自适应函数值减少的节点。最后更新$NBSet$并重复上述步骤，知道$NBSet$为空。</p>
<p><strong>（4）社区优化</strong></p>
<p>&emsp;&emsp;在社区拓展过程中，可能还会存在不属于任何社区的自由节点，而且社区集合中还会出现相似度高的社区。因此需要对社区进行优化。首先，计算节点和社区的相似度，把自由节点分到相似度最高的社区；然后，根据公式（6）计算社区与社区之间的相似度，合并相似度高的社区；最后输出网络社区划分的结果</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">dede</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dede</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
